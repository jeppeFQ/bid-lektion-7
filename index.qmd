---
title: "Softwaredesign pt. II + workshop II"
subtitle: ""
author: "Jeppe Fjeldgaard Qvist"
date: today
format: 
  revealjs:
    #include-after-body: "resources/timer.html"
    navigation-mode: linear
    slide-number: c
    show-slide-number: print
    embed-resources: true
    self-contained-math: true
    smaller: true
    scrollable: true
    theme: default
    include-in-header: 
      - text: |
          <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
          <style>
          .reveal {
            font-family: "Libre Baskerville", serif !important;
          }
          .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
            font-family: "Libre Baskerville", serif !important;
          }
          .reveal .slides section {
            overflow: visible !important;
          }
          .reveal ul, .reveal ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
            overflow: visible !important;
          }
          .reveal li {
            margin-bottom: 0.25em;
            overflow: visible !important;
          }
          </style>
---

## Dagens program 

* Softwaredesign og -modellering
* Workshop

## Softwaredesign: Formål iht. kodning

> Når vi taler om softwaredesign, taler vi om hvordan vi planlægger og organiserer vores kode, før vi skriver den eller mens vi skriver den. 

* Det primære formål er at gøre din kode begribelig for andre mennesker, **inklusive dit fremtidige jeg**.
* Når koden er organiseret logisk, kan du lettere genbruge dele af den i nye projekter. 
* Et godt design gør det også meget lettere at samarbejde. Hvis tre personer skal arbejde på samme program, og alle skriver kode på vidt forskellige måder, bliver det hurtigt kaos. Med klare designprincipper ved alle hvordan tingene skal struktureres.

---

* Organisere din kode så den er nem at forstå og vedligeholde
* Genbruge kode i stedet for at gentage dig selv
* Samarbejde bedre med andre programmører
* Finde og rette fejl hurtigere
* Udvide dit program uden at ødelægge eksisterende funktionalitet

## Succes-kriterier

* Let at læse
* Let at vedligeholde
* Let at udvide
* Let at fejlsøge

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Dårligt eksempel: svært at læse
def b(k):
    s=0
    for i in k:s+=i
    return s/len(k)
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Godt eksempel: let at læse og forstå
def beregn_gennemsnit(karakterer):
    """Beregner gennemsnit af en liste af karakterer"""
    total = sum(karakterer)
    antal = len(karakterer)
    gennemsnit = total / antal
    return gennemsnit
```
:::
:::

# Design-principper: *Guidelines ikke love*

## DRY (Don't Repeat Yourself)

Undgå at skrive den samme kode flere gange. Hver gang du kopierer kode, skaber du problemer for fremtiden. Hvis du finder en fejl i den kopierede kode, skal du huske at rette den alle steder.

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# DÅRLIGT: Gentagen kode
def beregn_løn_direktør(timer, timeløn):
    grundløn = timer * timeløn
    bonus = grundløn * 0.20
    return grundløn + bonus

def beregn_løn_manager(timer, timeløn):
    grundløn = timer * timeløn
    bonus = grundløn * 0.15
    return grundløn + bonus
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true

# GODT: Genbrugelig funktion
def beregn_løn(timer, timeløn, bonus_procent):
    grundløn = timer * timeløn
    bonus = grundløn * bonus_procent
    return grundløn + bonus
```
:::
:::

## Separation of Concerns

Hver del af dit program skal have ét klart ansvar. Det er som at organisere dit køkken: knive i én skuffe, tallerkener i ét skab, og madvarer i køleskabet. Du blander ikke tingene sammen.

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Dårligt: Én funktion gør ALT
def haandter_person():
    navn = input("Indtast navn: ")
    alder = int(input("Indtast alder: "))
    
    # Gemmer direkte i fil
    with open("personer.txt", "a") as fil:
        fil.write(f"{navn},{alder}\n")
    
    # Beregner noget
    if alder >= 18:
        print(f"{navn} er myndig")
    else:
        print(f"{navn} er ikke myndig")
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Godt: Hver funktion har ét ansvar

def indlaes_person_fra_bruger():
    """Ansvar: Kommunikere med brugeren"""
    navn = input("Indtast navn: ")
    alder = int(input("Indtast alder: "))
    return {"navn": navn, "alder": alder}

def gem_person_i_fil(person, filnavn="personer.txt"):
    """Ansvar: Gemme data"""
    with open(filnavn, "a") as fil:
        fil.write(f"{person['navn']},{person['alder']}\n")

def er_myndig(alder):
    """Ansvar: Beregne om en person er myndig"""
    return alder >= 18

def vis_myndighedsstatus(person):
    """Ansvar: Vise information til brugeren"""
    if er_myndig(person['alder']):
        print(f"{person['navn']} er myndig")
    else:
        print(f"{person['navn']} er ikke myndig")

# Nu koordinerer vi bare funktionerne
def main():
    person = indlaes_person_fra_bruger()
    gem_person_i_fil(person)
    vis_myndighedsstatus(person)
```
:::
:::

## KISS (Keep It Simple, Stupid)

Gør ikke tingene mere komplicerede end nødvendigt. Begyndere har ofte en tendens til at skrive meget kompleks kode for at virke smarte, men **den bedste kode er faktisk den simpleste kode der løser problemet**.

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Overkompleks: Prøver at være for smart
def find_stoerste(tal_liste):
    return sorted(tal_liste, reverse=True)[0] if tal_liste and isinstance(tal_liste, list) and all(isinstance(x, (int, float)) for x in tal_liste) else None
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Simpel og klar
def find_stoerste(tal_liste):
    """Finder det største tal i en liste"""
    if not tal_liste:
        return None
    return max(tal_liste)
```
:::
:::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Overkompleks
def er_lige(tal):
    return True if tal % 2 == 0 else False
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Simpel
def er_lige(tal):
    return tal % 2 == 0
```
:::
:::

## YAGNI (You Aren't Gonna Need It)

Byg ikke funktionalitet "bare i tilfælde af". Lad være med at tænke: "Måske skal jeg kunne gemme data i både en fil OG en database OG sende det over internettet", og bygger så alle tre systemer selvom vi kun har brug for ét.

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# Overdesign: Bygger ting vi ikke har brug for
class Person:
    def __init__(self, navn, alder):
        self.navn = navn
        self.alder = alder
        self.adresse = None  # Måske har vi brug for dette senere?
        self.telefon = None  # Og dette?
        self.email = None    # Og dette?
        self.cvr_nummer = None  # Hvad nu hvis det er en virksomhed?
        self.favorit_farve = None  # Man ved aldrig...
    
    def gem_i_database(self):
        # Har ikke en database endnu, men bygger metoden alligevel
        pass
    
    def send_email(self):
        # Har ikke email-funktionalitet, men bygger strukturen
        pass
```
:::
:::

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
# YAGNI: Byg kun hvad du har brug for NU
class Person:
    def __init__(self, navn, alder):
        self.navn = navn
        self.alder = alder
    
    def __str__(self):
        return f"{self.navn}, {self.alder} år"

# Når vi faktisk HAR brug for mere, tilføjer vi det
```
:::
:::

## Best Practices Tjekliste

* Er der klar separation of concerns?
* Er koden DRY (ingen duplikering)?
* Er navngivning konsistent og beskrivende?
* Er der passende abstraktion?
* Er koden testbar?
* Er der dokumentation hvor nødvendigt?

## Softwaredesign: et udviklingsperspektiv

> "A model of a system or process is a theoretical description that can help you understand how the system or process works, or how it might work."

* Modeller hjælper os med gradvist at formalisere et referentsystem samtidigt med at arbejdet med modellerne øger vores forståelse af referentsystemet. 

*Værd at huske:*

* En model kan ikke beskrive alle væsentlige elementer af et system: modellen bliver for kompleks og tjener ikke længere sit formål.
* Modeller er redskaber til at forstå og formidle. 

*Softwaremodeller:*

* Når vi skal bygge et komplekst system, har vi brug for måder at visualisere og diskutere systemet uden at skulle skrive tusindvis af linjer kode først.
* Modeller giver os et fælles sprog at tale i.
* De hjælper os med at opdage problemer tidligt, før vi har investeret uger i at skrive kode der ikke fungerer sammen på den rigtige måde.

## Objekt-Orienteret Analyse og -Design

* Et ret stort emne – der er skrevet indtil flere bøger om emnet ...
* Grundlæggende set en made at tilpasse sit designsprog (og programmeringssprog) til problemdomænet.
* Det giver os et udvalg af redskaber til at analysere og beskrive systemer på. Disse kan efterfølgende udtrykkes som:
    * **UML diagrammer**
    * Tekstuelle beskrivelser / Analyser
    * **Kode** (direkte repræsentation hvis sproget understøtter Objekt Orienteret programmering)

## UML: Unified Modeling Language

Link til [OMG UML](https://www.omg.org/spec/UML/2.5.1/PDF). 

* Før UML eksisterede, havde forskellige virksomheder og udviklere deres egne måder at tegne softwarediagrammer på. Det var lidt som hvis hvert land havde sit eget alfabet. Det fungerede fint internt, men når folk skulle samarbejde på tværs af organisationer, opstod der forvirring. 

UML er meget omfattende og indeholder fjorten forskellige diagramtyper. Vis skal (kun) se på:

* Use-Cases
* Proces eller aktivitetsdiagrammer
* Klasse diagrammer
* Sekvensdiagrammer

## Use-Case diagrammer

Et use-case diagram viser hvem der bruger systemet og hvad de gør med det. Her et simpelt bibliotekssystem:

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```
Låner                          Bibliotekar
      |                                |
      |                                |
      |---(Søg efter bog)              |
      |                                |
      |---(Lån bog)                    |
      |           (Registrer ny bog)---│
      |                                |
      |---(Aflever bog)                |
      |           (Administrer lånere)─│
      |                                |
      
```
:::
:::

* Beskriver aktører der interagerer med systemet (direkte og indirekte) samt de enkelte brugsscenarier hvori interaktionen foregår.
* Beskriver forskellige relationer mellem use-cases

---

Use-case diagram *udtrykt* i Python-sprog

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
def soeg_bog(titel):
    """Låner kan søge efter en bog"""
    pass

def laan_bog(laaner_id, bog_id):
    """Låner kan låne en bog"""
    pass

def aflever_bog(laan_id):
    """Låner kan aflevere en bog"""
    pass

def registrer_ny_bog(titel, forfatter, isbn):
    """Bibliotekar kan registrere ny bog"""
    pass

def administrer_laaner(laaner_id, handling):
    """Bibliotekar kan administrere lånere"""
    pass
```
:::
:::

## Procesdiagrammer

Et procesdiagram viser skridt for skridt hvad der sker i en proces. Her processen for at logge ind på et system:

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```
    START
      │
      ▼
    [Bed om brugernavn]
      │
      ▼
    [Bed om password]
      │
      ▼
    <Er password korrekt?>
      │           │
     JA          NEJ
      │           │
      ▼           ▼
    [Vis        [Vis
     velkomst    fejl]
     besked]      │
      │           │
      ▼           ▼
    [Åbn         [Prøv
     hoved-       igen?]
     menu]         │
      │           JA
      │           │
      ▼           └──────┐
    SLUT                 │
      ▲                  │
      └──────────────────┘
```
:::
:::

* Procesdiagrammer nedbryder en proces i sine bestanddele. 

---

Procesdiagram *udtrykt* i Python-sprog

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
def log_ind():
    """Håndterer login-processen"""
    max_forsoeg = 3
    forsoeg = 0
    
    while forsoeg < max_forsoeg:
        # Bed om brugernavn
        brugernavn = input("Indtast brugernavn: ")
        
        # Bed om password
        password = input("Indtast password: ")
        
        # Er password korrekt?
        if tjek_password(brugernavn, password):
            # Vis velkomst besked
            print(f"Velkommen, {brugernavn}!")
            # Åbn hovedmenu
            vis_hovedmenu()
            return True
        else:
            # Vis fejl
            forsoeg += 1
            print(f"Forkert password. {max_forsoeg - forsoeg} forsøg tilbage.")
    
    print("For mange fejlslagne forsøg. Prøv igen senere.")
    return False
```
:::
:::

## Klassediagrammer

Et klassediagram viser de klasser vi har i vores program og hvordan de hænger sammen. Her et eksempel med et simpelt skole-system:

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```
    ┌──────────────────┐
    │     Person       │
    ├──────────────────┤
    │ - navn: str      │
    │ - alder: int     │
    ├──────────────────┤
    │ + __init__()     │
    │ + __str__()      │
    └────────▲─────────┘
             │
             │ (arver fra)
       ┌─────┴─────┐
       │           │
    ┌──▼───────┐ ┌─▼────────┐
    │  Elev    │ │  Lærer   │
    ├──────────┤ ├──────────┤
    │ - klasse │ │ - fag    │
    ├──────────┤ ├──────────┤
    │+ studer()│ │+ undervis│
    └──────────┘ └──────────┘
```
:::
:::

::: {style="font-size: 0.6em;"}
* Beskriver de klasser af elementer (objekter) som systemet består af samt deres:
    * Indbygget Data (**properties**)
    * Indbygget Funktionalitet (**Methods**)
    * Relationer til hinanden (**generalization**, **aggregation**, **dependancy** & **composition**)
    * Tilgængelighed (**public**, **private** & **protected**)
:::

---

Klassediagram *udtrykt* i Python-sprog

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
class Person:
    """Basisklasse for alle personer"""
    def __init__(self, navn, alder):
        self.navn = navn  # - betyder privat i UML, men Python har ikke rigtig private
        self.alder = alder
    
    def __str__(self):
        return f"{self.navn}, {self.alder} år"

class Elev(Person):
    """En elev er en person der går i en klasse"""
    def __init__(self, navn, alder, klasse):
        super().__init__(navn, alder)  # Kalder Person's __init__
        self.klasse = klasse
    
    def studer(self, emne):
        print(f"{self.navn} studerer {emne}")

class Laerer(Person):
    """En lærer er en person der underviser i et fag"""
    def __init__(self, navn, alder, fag):
        super().__init__(navn, alder)
        self.fag = fag
    
    def undervis(self):
        print(f"{self.navn} underviser i {self.fag}")

# Brug af klasserne
anna = Elev("Anna", 16, "2.a")
peter = Laerer("Peter Hansen", 45, "Matematik")

anna.studer("Matematik")  # Output: Anna studerer Matematik
peter.undervis()  # Output: Peter Hansen underviser i Matematik
```
:::
:::

## Sekvensdiagrammer

Et sekvensdiagram viser hvordan forskellige dele af programmet kommunikerer over tid. Her en elev, der logger ind og ser sine karakterer:

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```
Bruger           System               Database
  │                │                     │
  │──login()──────>│                     │
  │                │                     │
  │                │──hent_bruger()─────>│
  │                │<───bruger_data──────┤
  │                │                     │
  │<──velkomst─────┤                     │
  │                │                     │
  │─vis_karakterer>│                     │
  │                │──hent_karakterer()─>│
  │                │<───karakter_liste───┤
  │                │                     │
  │<──karakterer───┤                     │
  │                │                     │
```
:::
:::

::: {style="font-size: 0.7em;"}
* Beskriver kommunikationen mellem systemets væsentlige elementer
* Viser hvornår disse elementer eller subsystemer er aktive 
* Lister kommunikation sekventielt 
* Skelner mellem signaler der oprinder hos et bestemt subsystem og signaler som er reaktioner på andre signaler.
:::

---

Sekvensdiagram *udtrykt* i Python-sprog

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
class BrugerInterface:
    """Håndterer kommunikation med brugeren"""
    def __init__(self, system):
        self.system = system
    
    def login(self, brugernavn, password):
        # Bruger kalder login
        bruger = self.system.hent_bruger(brugernavn, password)
        if bruger:
            print(f"Velkommen, {bruger.navn}!")
            return bruger
        return None
    
    def vis_karakterer(self, bruger):
        # Bruger beder om at se karakterer
        karakterer = self.system.hent_karakterer(bruger.id)
        for karakter in karakterer:
            print(f"{karakter.fag}: {karakter.værdi}")

class System:
    """Koordinerer mellem brugerinterface og database"""
    def __init__(self, database):
        self.database = database
    
    def hent_bruger(self, brugernavn, password):
        # System kommunikerer med database
        return self.database.find_bruger(brugernavn, password)
    
    def hent_karakterer(self, bruger_id):
        # System henter karakterer fra database
        return self.database.find_karakterer(bruger_id)

class Database:
    """Håndterer al data"""
    def find_bruger(self, brugernavn, password):
        # Simulerer database opslag
        pass
    
    def find_karakterer(self, bruger_id):
        # Simulerer database opslag
        pass
```
:::
:::

# Mini-projekter 

## Dagens (første) fokus: 1 time 

```{python}
#| eval: false
#| echo: true
import csv
import os

# --- Klasser ---
class Person:
    def __init__(self, navn, alder, køn):
        self.navn = navn
        self.alder = alder
        self.køn = køn

    def __str__(self):
        return f"Navn: {self.navn}, Alder: {self.alder}, Køn: {self.køn}"

    @property
    def alder(self) -> int:
        return self._alder

    @alder.setter
    def alder(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise TypeError("Alder skal være et heltal; decimaltal afrundes") from None
        if value < 0:
            raise ValueError("Alder kan ikke være negativ")
        self._alder = value
        
class Elev(Person):
    def __init__(self, navn, alder, køn, skole, klassetrin):
        super().__init__(navn, alder, køn)
        self.skole = skole
        self.klassetrin = klassetrin

    def __str__(self):
        return f"{super().__str__()}, Skole: {self.skole}, Klassetrin: {self.klassetrin}"


# --- Filnavn ---
FILENAME = "personliste.csv"


# --- Gem listen til CSV ---
def gem_personer_csv(personer):
    # Find mappen hvor .py filen ligger
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Kombiner med filnavnet
    filepath = os.path.join(script_dir, FILENAME)
    
    felt_navn = ["navn", "alder", "køn", "skole", "klassetrin"]
    with open(filepath, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=felt_navn)
        writer.writeheader()
        for p in personer:
            row = {
                "navn": p.navn,
                "alder": p.alder,
                "køn": p.køn,
                "skole": getattr(p, "skole", ""),
                "klassetrin": getattr(p, "klassetrin", "")
            }
            writer.writerow(row)
    print(f"Listen er gemt i '{filepath}' (CSV-fil).")


# --- Indlæs liste fra CSV ---
def indlaes_personer_csv():
    # Find mappen hvor .py filen ligger
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Kombiner med filnavnet
    filepath = os.path.join(script_dir, FILENAME)
    
    personer = []
    if os.path.exists(filepath):
        with open(filepath, "r", newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                navn = row["navn"]
                alder = int(row["alder"])
                køn = row["køn"]
                skole = row.get("skole", "")
                klassetrin = row.get("klassetrin", "")
                if skole or klassetrin:
                    personer.append(Elev(navn, alder, køn, skole, klassetrin))
                else:
                    personer.append(Person(navn, alder, køn))
        print(f"{len(personer)} personer/elev indlæst fra '{filepath}'")
    else:
        print("Ingen tidligere fil fundet, starter med tom liste.")
    return personer


# --- Terminalprogram ---
def main():
    personer = indlaes_personer_csv()  # indlæs eksisterende CSV

    while True:
        print("\n--- Person/Elev Registrering ---")
        print("1. Tilføj person")
        print("2. Vis alle personer")
        print("3. Tilføj person til skole")
        print("4. Gem liste som CSV")
        print("5. Afslut")
        valg = input("Vælg en mulighed: ")

        if valg == "1":
            navn = input("Indtast navn: ")
            alder = input("Indtast alder: ")
            køn = input("Indtast køn: ")
            try:
                alder = int(alder)
                p = Person(navn, alder, køn)
                personer.append(p)
                print("Person tilføjet!")
            except ValueError:
                print("⚠ Alder skal være et heltal.")

        elif valg == "2":
            if not personer:
                print("Ingen personer registreret endnu.")
            else:
                print("\n--- Registrerede personer/elev ---")
                for i, person in enumerate(personer, start=1):
                    print(f"{i}. {person}")

        elif valg == "3":
            ikke_elever = [p for p in personer if not isinstance(p, Elev)]
            if not ikke_elever:
                print("Ingen personer at opgradere.")
                continue

            print("\nVælg en person at opgradere til elev:")
            for i, person in enumerate(ikke_elever, start=1):
                print(f"{i}. {person}")

            try:
                valg_index = int(input("Nummer: ")) - 1
                person_valgt = ikke_elever[valg_index]
            except (ValueError, IndexError):
                print("Ugyldigt valg.")
                continue

            skole = input("Indtast skole: ")
            klassetrin = input("Indtast klassetrin: ")
            elev = Elev(person_valgt.navn, person_valgt.alder, person_valgt.køn, skole, klassetrin)
            personer[personer.index(person_valgt)] = elev
            print(f"{elev.navn} er nu elev på {skole}, klassetrin {klassetrin}!")

        elif valg == "4":
            gem_personer_csv(personer)

        elif valg == "5":
            print("Program afsluttes.")
            gem_personer_csv(personer)
            break

        else:
            print("Ugyldigt valg, prøv igen.")


if __name__ == "__main__":
    main()

```

## Dagens (andet) fokus: resten af dagen ... 

* Introduktion til resten af workshop-forløbet
* Tilføj nye klasser til vores system (OOP: arv, indkapsling, validering, komposition, referencer)
* Diskussion af **brugen af AI i en udviklingsprocess** 
    * Hvor er det meningsfuldt som et **værktøj** 
    * Hvor er der "ricisi" ved ikke selv at have fingrene på tasteturet og *se* hvad der bliver implementeret
    * Hvad er *forudsætningerne* for overhovedet at lave en meningsfuld prompt til at hjælpe i kodningen

## Workshop II (+III +IIII +V)

> En lille skole har brug for at administrere deres $N$ elever og $N$ lærere. De skal kunne se hvem der underviser i hvilke fag, hvilke elever der er i hvilke klasser, og kunne kontakte relevante personer hurtigt. Tidligere brugte de bare et Excel-ark, men det blev hurtigt uoverskueligt.

* **I skal lave en tilsvarende problemformulering, der afgrænser formålet med jeres program.** 

## Del 1: Fra personliste til skolesystem

Vi tager afsæt i registreringsprogrammet fra *Workshop I*, der kan registrere `personer` (fx en årgang af børn) og registrere disser personer til `elever`. Første konkrete udvidelse af dette system er at oprette en `Lærer-klasse` der kan håndtere at en lærer underviser i specifikke fag.

1. ***Lærerklassen***: Vi implementerer `Lærer-klassen` med en liste af fag de kan undervise i, plus deres kontaktinformation (email og telefonnummer).
    * `properties` for email-validering
    * En property på email kan tjekke at der er et "@"-tegn og et domæne, hvilket beskytter systemet mod "dårlig" data.
    * **FORMÅL**: Se at `properties` ikke bare er "pæn syntaks", men aktiv "beskyttelse" af data-integritet i systemer hvor dårlig data kan have konsekvenser og forstå at `arv` her giver mening fordi både `Elev` og `Lærer` deler grundlæggende persondata, men har forskellige roller og behov.

---

Næste problem er at skolen skal kunne danne klasser for det nye skoleår.

2. ***Skoleklasse***: Når en ny klasse oprettes, skal den have et navn (fx "7A"), et klasselokale, en klasselærer, og skal kunne tilføje elever. Skolen skal kunne `printe` klasselister og se om en klasse er fuld. 
    * Oprettelse af Skoleklasse-klasse der indeholder en liste af Elev-objekter og en reference til en Lærer-objekt som klasselærer. Klassen får metoder som `tilføj_elev()`, `fjern_elev()`, og `er_fuld()`.
    * **Komposition** i praksis: en Skoleklasse "ejer" ikke elever, men har en relation til dem.
    * Forskellen mellem at gemme en **reference** til et objekt versus at kopiere data: Når man tilføjer en elev til en klasse, tilføjer man en reference, så hvis elevens information opdateres ét sted, reflekteres det alle steder. 
    * **FORMÅL**: Forstå forskellen mellem `værdityper` og `referencer`, og hvordan objekter kan organisere andre objekter uden at eje dem. Se værdien af at have en klasse til at håndtere forretningslogik (som "er klassen fuld?").


---

Det tredje problem er mere subtilt. Skolen har opdaget at når de indtaster elever, sker der en fejl: En elev kan får tildelt klassetrin "10" selvom eleven kun er 12 år gammel, hvilket er usandsynligt. De har også brug for at kunne søge efter elever baseret på forskellige kriterier.

3. ***Validering***: Udvid `Elev-klassen` med properties for klassetrin og skole. 
    * Systemet giver en advarsel hvis alder og klassetrin ikke matcher typiske mønstre.
    * Køn accepterer specifikke værdier eller giver mulighed for selvdefinering.
    * Tilføjer også en `søg_metode` der kan finde elever baseret på forskellige kriterier. 
    * **FORMÅL**: Se at `validering` handler om data-kvalitet og konsistens. Forstå at `encapsulation` ikke bare handler om at "gemme" data, men om at sikre at objekter altid er i en gyldig tilstand. 


## Del 2: Fleksibilitet gennem abstraktion

Skolen vil nu også administrere administrativt personale (rektor, sekretær, vicerektor). Disse personer skal også kunne logge ind i systemet, have kontaktinfo, men har andre `rettigheder` og opgaver end lærere og elever.

1. Fælles interface gennem ***abstrakt basisklasse***: Menu-systemet skal kunne håndtere mange forskellige typer af personer, og hver type skal kunne "præsentere sig selv" forskelligt når man viser dem. En elev skal vise deres klasse, en lærer deres fag, og en administrator deres ansvarområde.
    * Oprettelse af en abstrakt `Rolle` basisklasse med `abstrakte metoder` som `vis_info()`, `beskriv_rolle()`, og `hent_kontakt_info()`. `Person-klassen` arver nu fra `Rolle`, og både `Elev`, `Lærer` og en ny `Administrator`-klasse skal implementere disse metoder på deres egen måde.
    * Menu-funktionen "Vis alle personer" kan nu iterere gennem en liste af Rolle-objekter og kalde vis_info() på hver, uden at bekymre sig om hvilken konkret type det er. Dette er `polymorfi` i praksis: Ét interface, mange implementationer.
    * **FORMÅL**: Forstå hvordan `abstraktion` gør koden fleksibel og udvidelsesvenlig. 
        * (Når skolen senere vil tilføje forældre til systemet, skal de bare oprette en Forælder-klasse der implementerer Rolle-interfacet, og resten af koden fortsætter med at virke uden ændringer.)

---

Nøste problem er at skolen vil kunne filtrere og søge på mange forskellige måder. (Fx finde alle elever i 7. klasse, finde alle lærere der underviser matematik, finde alle der bor i Aalborg, osv.)

2. ***Polymorfi i filtreringssystemet***: bygger et filtreringssystem, der opretter en abstrakt `Filter` klasse med en `matcher()` metode. Derefter lave konkrete filtre som `AldersFilter`, `KlasseFilter`, `FagFilter` osv. Søgefunktionen tager en liste af filtre og returnerer alle personer der matcher alle filtrene.
    * **FORMÅL**: Se et konkret eksempel på `Open/Closed Principle` (åben for udvidelse, lukket for modifikation). Systemet kan udvides med nye filtre uden at ændre eksisterende kode. 


## Del 3: Professionel arkitektur

Systemet bruges nu af tre forskellige skoler, og flere udviklere arbejder på koden. `Main`-funktionen er vokset til 300 linjer og er blevet uoverskuelig. Nye features tager lang tid at implementere fordi koden er tæt sammenvævet. `Bugs` opstår fordi én ændring påvirker uventede dele af systemet.

1. ***Command pattern for menu-handlinger***: Det konkrete problem er den massive main-funktion. Hver menu-handling er en lang if-else blok med blandet logik for input-håndtering, validering, forretningslogik, og output.
    * `Command pattern` anvendes ved at lave en abstrakt `MenuCommand` klasse med en `udfør()` metode. Hver menu-handling bliver sin egen klasse: `TilføjPersonCommand`, `VisAlleCommand`, `OpretKlasseCommand`, `TildelFagCommand` osv.
    * **FORMÅL**: Forstå `Single Responsibility Principle`: hver klasse har præcis ét ansvar og se hvordan opdeling i små klasser faktisk gør koden lettere at overskue, ikke sværere. 

---

2. ***Fuld refaktorering***: *Info følger ...*


